<html>
<head>
    <style>
        html,body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float amplitude;
        attribute float displacement;
        varying vec3 vNormal;

		void main() {
		    vNormal = normal;

            vec3 vertexPosition = position + normal * vec3(displacement * amplitude);

			gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
		}
	</script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vNormal;

		void main() {
		    vec3 light = vec3(0.1, 1.0, 1.0);
		    light = normalize(light);
		    float currentColor = max(0.0, dot(vNormal, light));

            vec3 color = vec3(currentColor, currentColor * 0.1, currentColor);

			gl_FragColor = vec4(color, 1);
		}
	</script>
</head>
<body>
<script src="three.min.js"></script>
<script>
    var WIDTH = 512;
    var HEIGHT = 384;

    var scene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer({  });
    renderer.setSize( WIDTH, HEIGHT );

    var camera = new THREE.PerspectiveCamera(75, WIDTH / HEIGHT, 1, 10000);
    camera.position.z = 100;

    var radius = 50;
    var segments = 32;
    var rings = 32;

    var geometry = new THREE.SphereGeometry(radius, segments, rings);

    var uniforms = {
        amplitude: {
            type: 'f',
            value: 0
        }
    };

    var attributes = {
        displacement: {
            type: 'f',
            value: []
        }
    };

    var material = new THREE.ShaderMaterial({
        vertexShader: document.getElementById('vertexshader').innerText,
        fragmentShader: document.getElementById('fragmentshader').innerText,
        attributes: attributes,
        uniforms: uniforms
    });

    var sphere = new THREE.Mesh(geometry, material);

    var values = attributes.displacement.value;
    for (var v = 0; v < sphere.geometry.vertices.length; v++) {
        values.push(Math.random() * 10);
    }

    scene.add(sphere);

    document.body.appendChild( renderer.domElement );

    var multiplier = 0;

    function renderLoop() {
        requestAnimationFrame(renderLoop);

        uniforms.amplitude.value = Math.cos(multiplier) * 2.5;

        multiplier += 0.05;

        renderer.render(scene, camera);
    }

    var state = false;
    document.onkeyup = function(e) {
        state = !state;
        if (e.keyCode === 32) {
            material.wireframe = state;
            renderer.render(scene, camera);
        }
    }

    renderLoop();
</script>
</body>
</html>
